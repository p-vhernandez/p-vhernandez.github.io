<!DOCTYPE html>
<html>
    <head>

        <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
        <meta content="utf-8" http-equiv="encoding">

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous">

        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap-theme.min.css" integrity="sha384-6pzBo3FDv/PJ8r2KRkGHifhEocL+1X2rVCTTkUfGk7/0pbek5mMa1upzvWbrUbOZ" crossorigin="anonymous">

        <script src="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd" crossorigin="anonymous"></script>

        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Nunito&display=swap" rel="stylesheet">

        <title>AB Testing Team 3</title>

        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js">
        </script>

        <!-- The core Firebase JS SDK is always required and must be listed first -->
        <script src="https://www.gstatic.com/firebasejs/8.4.3/firebase-app.js"></script>

        <!-- TODO: Add SDKs for Firebase products that you want to use
            https://firebase.google.com/docs/web/setup#available-libraries -->
        <script src="https://www.gstatic.com/firebasejs/8.4.3/firebase-firestore.js"></script>
        <script src="https://www.gstatic.com/firebasejs/8.4.3/firebase-analytics.js"></script>

        <script>

            let firebaseConfig = {
                apiKey: "AIzaSyDzuCmLyZDZVx5EcwbOF8bTBTgoKmV3aLg",
                authDomain: "evaluation-abtesting.firebaseapp.com",
                databaseURL: "https://evaluation-abtesting-default-rtdb.europe-west1.firebasedatabase.app",
                projectId: "evaluation-abtesting",
                storageBucket: "evaluation-abtesting.appspot.com",
                messagingSenderId: "493242964737",
                appId: "1:493242964737:web:b1a9ca8d906542844c9900",
                measurementId: "G-ELNLGRZKZ8"
            };
            
            firebase.initializeApp(firebaseConfig);

            let db = firebase.firestore();
            firebase.analytics();

            function getCookie(cname) {

                let name = cname + "=";
                let decodedCookie = decodeURIComponent(document.cookie);
                let ca = decodedCookie.split(';');
                for(let i = 0; i < ca.length; i++) {
                    let c = ca[i];
                    while (c.charAt(0) == ' ') {
                        c = c.substring(1);
                    }
                    if (c.indexOf(name) == 0) {
                        return c.substring(name.length, c.length);
                    }
                }
                return "cookie_not_found";

            }

            function setCookie(cname, cvalue, exdays) {

                let d = new Date();
                let extratime = exdays*24*60*60*1000;
                d.setTime(d.getTime() + (extratime));
                let expires = " expires="+ d.toUTCString();
                document.cookie = cname + "=" + cvalue + ";" + expires + "; path=/; samesite=lax";

            }

            function cookieExists(cname) {
                return (getCookie(cname) != "cookie_not_found" ? true : false);
            }

            function msToTime(duration) {
                let milliseconds = parseInt((duration % 1000) / 100),
                    seconds = Math.floor((duration / 1000) % 60),
                    minutes = Math.floor((duration / (1000 * 60)) % 60),
                    hours = Math.floor((duration / (1000 * 60 * 60)) % 24);

                hours = (hours < 10) ? "0" + hours : hours;
                minutes = (minutes < 10) ? "0" + minutes : minutes;
                seconds = (seconds < 10) ? "0" + seconds : seconds;

                return "~" + hours + (hours == 1 ? " hour, ": " hours, ") + minutes + (minutes == 1 ? " minute": " minutes");
            }

            function getStandardDeviation (array) {
                const n = array.length;
                const mean = array.reduce((a, b) => a + b) / n;
                return Math.sqrt(array.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n);
            }

            function getTwoMeansZValue(parameters) {
                // verbose on purpose

                let sm1 = parameters.sampleMean1,
                    sm2 = parameters.sampleMean2,
                    delta = parameters.popDelta,
                    sd1 = parameters.stdDev1,
                    sd2 = parameters.stdDev2,
                    size1 = parameters.sampleSize1,
                    size2 = parameters.sampleSize2;

                let numerator = (sm1 - sm2) - delta;

                let d1 = ((sd1**2)/size1);
                let d2 = ((sd2**2)/size2);
                let denominator = Math.sqrt(d1 + d2);

                return (numerator/denominator);
            }

            function getPValue(z) 
            {
                // z == number of standard deviations from the mean

                // if z is greater than 6.5 standard deviations from the mean
                // the number of significant digits will be outside of a reasonable 
                // range
                if (z < -6.5)
                    return 0.0;
                if (z > 6.5) 
                    return 1.0;

                let factK = 1;
                let sum = 0;
                let term = 1;
                let k = 0;
                let loopStop = Math.exp(-23);

                while(Math.abs(term) > loopStop) 
                {
                    term = .3989422804 * Math.pow(-1,k) * Math.pow(z,k) / (2 * k + 1) / Math.pow(2,k) * Math.pow(z,k+1) / factK;
                    sum += term;
                    k++;
                    factK *= k;

                }

                sum += 0.5;

                return (1 - sum);
            }

            function start() {
                let rightTimes = new Array(),
                    leftTimes = new Array(),
                    joinList = 0,
                    startTime = 0,
                    estDuration = 0,
                    endTime = 0;

                let popSize = 500,
                    currentPartition = 0,
                    totPartitions = 50, // CHANGE THESE VALUES TO THE FINAL ONES IN THE FINAL VERSION
                    partitionSize = 10,
                    expPower = 80,
                    currentSampleSize = 0,
                    sumRight = 0,
                    sumLeft = 0,
                    sampleMeanRight, 
                    sampleMeanLeft,
                    popMeanRight = 10000,
                    popMeanLeft = 13000,
                    popDelta = 0, // we're under the null hypothesis
                    stdDevRight = 0,
                    stdDevLeft = 0,
                    zValue = 0,
                    pValue = 0;

                // for now I'll use the two sample z test

                // protip: use the left one as baseline/population so you'll see 
                // whether the right one is statistically-significantly better?

                //db.collection("index").get().then((querySnapshot) => {
                db.collection("index").onSnapshot((querySnapshot) => {
                    querySnapshot.forEach((doc) => {
                        // doc.data() is never undefined for query doc snapshots
                        // console.log(doc.id, " => ", doc.data());
                        if (doc.data().joined) {
                            if (doc.data().button_position == "right")
                                rightTimes.push(doc.data().time_to_join);
                            else
                                leftTimes.push(doc.data().time_to_join);
                            // joinList++; // this will be useful for the second hyp
                        }
                    });

                    currentSampleSize = rightTimes.length + leftTimes.length;
                    currentPartition = totPartitions - ((popSize - currentSampleSize)/partitionSize);

                    let isItWhole = (currentPartition - Math.floor(currentPartition)) == 0;
   
                    if (!isItWhole)
                        currentPartition = Math.ceil(currentPartition);

                    db.collection("index").where("surname","==","Number 1").get().then((querySnapshot) => {
                        querySnapshot.forEach((doc) => {
                            startTime = Date.parse(doc.data().visits[0]);
                        });

                        db.collection("index").where("surname","==","Number " + currentSampleSize).get().then((querySnapshot) => {
                            querySnapshot.forEach((doc) => {
                                endTime = (Date.parse(doc.data().visits[0]) + doc.data().time_to_join);
                            });

                            // currentpart : duration = totparts : totdur -> duration * totparts / currentpart
                            estDuration = msToTime(((endTime - startTime) * totPartitions) / currentPartition);

                            estSingleDuration = msToTime((Date.now() - startTime) - (endTime - startTime));

                            for (let i = 0; i < rightTimes.length; i++)
                                sumRight += rightTimes[i];
                            
                            sampleMeanRight = sumRight/rightTimes.length;

                            for (let i = 0; i < leftTimes.length; i++)
                                sumLeft += leftTimes[i];

                            sampleMeanLeft = sumLeft/leftTimes.length;

                            stdDevRight = getStandardDeviation(rightTimes);
                            stdDevLeft = getStandardDeviation(leftTimes);

                            let package = {
                                sampleMean1: sampleMeanLeft,
                                sampleMean2: sampleMeanRight,
                                popDelta: popDelta,
                                stdDev1: stdDevLeft,
                                stdDev2: stdDevRight,
                                sampleSize1: leftTimes.length,
                                sampleSize2: rightTimes.length
                            };

                            zValue = getTwoMeansZValue(package);
                            pValue = getPValue(zValue);

                            document.getElementById("stats").innerHTML = "Z = " + zValue.toFixed(4) + ", p-value = " + pValue.toFixed(4) + " (" + (pValue >= 0.05 ? "non-" : "") + "significant)";

                            if (currentPartition != -1)
                                document.getElementById("latest").innerHTML = "Number of subjects that entered the experiment so far: " + currentSampleSize + 
                                    " (" + rightTimes.length + " had the right button position and " + leftTimes.length + " had the left button position)";
                            else
                                document.getElementById("latest").innerHTML = "Error? Current sample size: " + currentSampleSize;

                            if (isItWhole) {
                                document.getElementById("duration").innerHTML = "Estimated time until the end of the testing session (based on the duration so far): " + estDuration;
                                document.getElementById("pending").innerHTML = currentPartition + " interim " + (currentPartition == 1 ? "analysis" : "analyses") + " done, " + 
                                (totPartitions - currentPartition) + " interim " + (currentPartition == 49 ? "analysis" : "analyses") + " pending (total subjects = " + popSize + " for power = " + expPower + "%)";
                            }
                            else
                                document.getElementById("duration").innerHTML = "The interim analysis number " + currentPartition + " is in progress. The data in this page will be updated once it's finished." + 
                                " Estimated time until the end of the interim analysis in progress: " + estSingleDuration;

                            let xValues = ["1/10","2/10","3/10","4/10","5/10","6/10","7/10","8/10","9/10","10/10"];

                            setCookie("z" + currentPartition, zValue, 365);

                            let resultZs = new Array();
                            resultZs[currentPartition-1] = zValue;
                            // WIP: get cookies; you know that there are N previous partitions because that's currentPartition-1, so you can more efficiently cycle through getting them

                            for (let i = 0; i < (currentPartition - 1); i++) {
                                resultZs[i] = getCookie("z" + (i + 1));
                            }

                            // These values come from the R script
                            let interimZs = [6.0879, 4.2288, 3.3962, 2.9061, 2.5789, 2.3417, 2.1598, 2.0146, 1.8952, 1.7949];
                            let nInterimZs = [-6.0879, -4.2288, -3.3962, -2.9061, -2.5789, -2.3417, -2.1598, -2.0146, -1.8952, -1.7949];

                            let judgementSoFar = "NOT ";

                            // improve: compare the absolute value with the positive interimZs value, since it's symmetrical
                            // we can do this because the curves are symmetrical, but if they weren't (e.g. the f test) then we would need to do it verbosely
                            if (resultZs[resultZs.length - 1] > 0) {
                                if (resultZs[resultZs.length -1] > interimZs[resultZs.length - 1])
                                    judgementSoFar = "";
                            } else {
                                if (resultZs[resultZs.length -1] < nInterimZs[resultZs.length - 1])
                                    judgementSoFar = "";
                            }

                            document.getElementById("judgement").innerHTML = "Judging by the data we got so far, we can say that the alternative hypothesis is " + judgementSoFar + "statistically significant";

                            // Should I keep both grey lines in the chart? Or should I differentiate based on the last value being positive or negative and only keep the appropriate one?
                            // ANSWER: I should only keep one, since we're testing a 1-tailed hypothesis
                            // BUT I should keep and show both
                            // the following plot also works with 2-tailed hypotheses
                            new Chart("myChart", {
                                type: "line",
                                data: {
                                    labels: xValues,
                                    datasets: [{
                                        data: interimZs,
                                        borderColor: "grey", // light grey
                                        fill: false
                                    },
                                    {
                                        data: nInterimZs,
                                        borderColor: "grey", // light grey
                                        fill: false
                                    },
                                    {
                                        data: resultZs,
                                        borderColor: "purple",
                                        fill: false
                                    }]
                                },
                                options: {
                                    legend: {display: false}
                                }
                            });
                        });
                    });
                });
            }

        </script>

    </head>

    <body style="font-family: 'Nunito', sans-serif;" onload="start()">
        <div class="jumbotron text-center">
            <h1>Dashboard</h1>
        </div>
        <div class="container">
            <div class="row">
                <h3 id="latest" style="line-height: 1.6"></h3>
                <h3 id="stats" style="line-height: 1.6"></h3>
                <h3 id="pending" style="line-height: 1.6"></h3>
                <h4 id="duration" style="line-height: 1.6"></h4>
                <h3 id="judgement" style="line-height: 1.6"></h3>
                <h4 style="line-height: 1.6">Currently testing a 1-tailed hypothesis</h4>
                <br>
                <canvas id="myChart" style="width:100%;max-width:700px"></canvas>
            </div>
            <div class="row" style="height: 30px;">
                <br><br><br><br><br><br><br><br><br><br>
            </div>
        </div>
    </body>
</html>
